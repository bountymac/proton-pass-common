namespace proton_pass_common_mobile {
    string library_version();
};

[Error]
enum AliasPrefixError {
    "TwoConsecutiveDots",
    "InvalidCharacter",
    "DotAtTheEnd",
    "PrefixTooLong",
    "PrefixEmpty",
    "DotAtTheBeginning"
};

interface AliasPrefixValidator {
    constructor();
    [Throws=AliasPrefixError]
    void validate(string prefix);
};


dictionary Login {
    string title;
    string username;
    string password;
    string? totp;
    sequence<string> urls;
};

[Error]
enum LoginError {
    "InvalidTOTP",
    "InvalidURL",
};

interface LoginValidator {
    constructor();
    [Throws=LoginError]
    void validate(Login login);
};

interface EmailValidator {
    constructor();
    boolean is_email_valid(string email);
};

[Error]
enum TOTPError {
    "NotTotpUri",
    "InvalidAuthority",
    "NoAuthority",
    "InvalidAlgorithm",
    "InvalidScheme",
    "URLParseError",
    "NoSecret",
    "EmptySecret",
    "NoQueries",
    "SystemTimeError"
};

enum TOTPAlgorithm {
    "SHA1",
    "SHA256",
    "SHA512"
};

dictionary TOTP {
    string? label;
    string secret;
    string? issuer;
    TOTPAlgorithm? algorithm;
    u8? digits;
    u16? period;
};

interface TotpUriSanitizer {
    constructor();
    string uri_for_editing(string original_uri);
    [Throws=TOTPError]
    string uri_for_saving(string original_uri, string edited_uri);
};

interface TotpUriParser {
    constructor();
    [Throws=TOTPError]
    TOTP parse(string uri_string);
};

[Error]
enum PasswordGeneratorError {
    "FailToGenerate",
};

dictionary RandomPasswordConfig {
    u32 length;
    boolean numbers;
    boolean uppercase_letters;
    boolean symbols;
};

interface RandomPasswordGenerator {
    constructor();
    [Throws=PasswordGeneratorError]
    string generate(RandomPasswordConfig config);
};

enum WordSeparator {
    "Hyphens",
    "Spaces",
    "Periods",
    "Commas",
    "Underscores",
    "Numbers",
    "NumbersAndSymbols",
};

dictionary PassphraseConfig {
    WordSeparator separator;
    boolean capitalise;
    boolean include_numbers;
};

interface PassphraseGenerator {
    constructor();
    sequence<string> random_words(u32 word_count);
    string generate_passphrase(sequence<string> words, PassphraseConfig config);
};

enum PasswordScore {
    "VeryDangerous",
    "Dangerous",
    "VeryWeak",
    "Weak",
    "Good",
    "Strong",
    "VeryStrong",
    "Invulnerable",
};

interface PasswordScorer {
    constructor();
    PasswordScore check_score(string password);
};

interface TotpTokenGenerator {
    constructor();
    [Throws=TOTPError]
    string generate_current_token(TOTP totp);
};